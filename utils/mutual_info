#!python

import numpy as np
import cv2
import sys
import math
import random
from sklearn.metrics import mutual_info_score, normalized_mutual_info_score
import argparse


#parser =argparse.ArgumentParser(description="Computes Mutual Information between two images")

file1 = sys.argv[1]
file2 = sys.argv[2]
numpoints = int(sys.argv[3])

#im1 = Image.open(file1)
#im2 = Image.open(file2)

im1: np.ndarray = cv2.imread(file1)
im2: np.ndarray = cv2.imread(file2)

if im1.shape[0] < im2.shape[0]:
    im2 = cv2.resize(im2, dsize=(im1.shape[1], im1.shape[0]), interpolation=cv2.INTER_NEAREST)
elif im1.shape[0] > im2.shape[0]:
    im1 = cv2.resize(im1, dsize=(im2.shape[1], im2.shape[0]), interpolation=cv2.INTER_NEAREST)
assert(im1.shape[:2] == im2.shape[:2])

uid1 = {}
uid2 = {}

xmin = math.ceil(im1.shape[1] / 4); xmax = math.floor(im1.shape[1] * 3 / 4)
ymin = math.ceil(im1.shape[0] / 4); ymax = math.floor(im1.shape[0] * 3 / 4)
if (ymax - ymin) * (xmax - xmin) <= numpoints:
    sampling_points_yx = [(y, x) for x in range(xmin, xmax) for y in range(ymin, ymax)]
else:
    sampling_points_yx = [(random.randrange(ymin, ymax),random.randrange(xmin, xmax)) for i in range(numpoints)]
ids1 = []
ids2 = []
for p in sampling_points_yx:
    v1 = tuple(im1[p])
    v2 = tuple(im2[p])

    if v1 not in uid1:
        uid1[v1] = len(uid1)
    if v2 not in uid2:
        uid2[v2] = len(uid2)

    ids1.append(uid1[v1])
    ids2.append(uid2[v2])

ids3 = [ random.randrange(1, len(uid1)) for i in range(len(sampling_points_yx)) ]

#print(ids1)
#print(ids2)

print(normalized_mutual_info_score(ids1, ids2))
#print(normalized_mutual_info_score(ids1, ids3))
